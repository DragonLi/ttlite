let t = \ (x :: *) -> x;

let id  = (\ (a :: *) (x :: a) -> x )
    :: forall (a :: *) . a -> a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *). forall (b :: *) . a -> b -> a;

let const1 = (\ (a :: *) (x :: a) (b :: *) (y :: b) -> x)
    :: forall (a :: *). a -> forall (b :: *) . b -> a;

-- TODO we need true universes here in order to specify fst and snd
-- let fst = sigmaElim (exists (x :: Nat) . Eq Nat x 1;)

let tmp = \ (a :: *) (b :: *) (p :: (exists (x :: a) . b)) -> p;


assume (A :: *);
assume (B :: *);
assume (p :: (exists (x :: A) . B));

assume (xa :: A);
assume (xb :: B);

let m = \ (_ :: exists (x :: A) . B) -> A;
let f = \(x :: A) (y :: B) -> x;

let p1 = dpair (exists (x :: A) . B) xa xb;

let e = sigmaElim (exists (x :: A) . B) m f p;
let e1 = sigmaElim (exists (x :: A) . B) m f p1;

let fst0 = \ (p2 :: (exists (x :: A) . B)) -> sigmaElim (exists (x :: A) . B) m f p2;

-- fst for non-dependent pairs
let fst = \ (a :: *) (b :: *) (p :: (exists (x :: a) . b)) ->
            sigmaElim
                (exists (x :: a) . b)
                (\ (_ :: exists (x :: a) . b) -> a)
                (\(x :: a) (y :: b) -> x)
                p;

let snd = \ (a :: *) (b :: *) (p :: (exists (x :: a) . b)) ->
            sigmaElim
                (exists (x :: a) . b)
                (\ (_ :: exists (x :: a) . b) -> b)
                (\(x :: a) (y :: b) -> y)
                p;

-- true fst - works only with universes or with macros

let fst1 = \ (a :: *) (b :: a -> *) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (_ :: exists (x :: a) . b x) -> a)
                (\(x :: a) (y :: b x) -> x)
                p;

let snd1 = \ (a :: *) (b :: a -> *) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (p :: (exists (x :: a) . b x)) -> b (fst1 a b p))
                (\(x :: a) (y :: b x) -> y)
                p;
