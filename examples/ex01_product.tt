let t = \ (x :: Set) -> x;

let id  = (\ (a :: Set) (x :: a) . x )
    :: forall (a :: Set) (x :: a) . a;

let const = (\ (a :: Set) (b :: Set) (x :: a) (y :: b) -> x)
    :: forall (a :: Set) (b :: Set) (_ :: a) (_ :: b) . a;

let const1 = (\ (a :: Set) (x :: a) (b :: Set) (y :: b) -> x)
    :: forall (a :: Set) (_ :: a) (b :: Set) (_ :: b) . a;

-- TODO we need true universes here in order to specify fst and snd
-- let fst = sigmaElim (exists (x :: Nat) . Eq Nat x 1;)

--let tmp = \ (a :: *) (b :: *) (p :: (exists (x :: a) . b)) -> p;

assume (A :: Set);
assume (B :: Set);
assume (p :: (exists (x :: A) . B));

assume (xa :: A);
assume (xb :: B);

let m = \ (_ :: exists (x :: A) . B) -> A;
let f = \(x :: A) (y :: B) -> x;

let p1 = dpair (exists (x :: A) . B) xa xb;

let e = sigmaElim (exists (x :: A) . B) m f p;
let e1 = sigmaElim (exists (x :: A) . B) m f p1;

let fst0 = \ (p2 :: (exists (x :: A) . B)) -> sigmaElim (exists (x :: A) . B) m f p2;


-- fst for non-dependent pairs
let fst = \ (a :: Set) (b :: Set) (p :: (exists (x :: a) . b)) ->
            sigmaElim
                (exists (x :: a) . b)
                (\ (_ :: exists (x :: a) . b) -> a)
                (\(x :: a) (y :: b) -> x)
                p;

let snd = \ (a :: Set) (b :: Set) (p :: (exists (x :: a) . b)) ->
            sigmaElim
                (exists (x :: a) . b)
                (\ (_ :: exists (x :: a) . b) -> b)
                (\(x :: a) (y :: b) -> y)
                p;

-- true fst - works only with universes or with macros
let fst1 = \ (a :: Set) (b :: (forall (_ :: a). Set)) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (_ :: exists (x :: a) . b x) -> a)
                (\(x :: a) (y :: b x) -> x)
                p;

let snd1 = \ (a :: Set) (b :: (forall (_ :: a). Set)) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (p :: (exists (x :: a) . b x)) -> b (fst1 a b p))
                (\(x :: a) (y :: b x) -> y)
                p;
