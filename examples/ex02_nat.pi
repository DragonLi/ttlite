let id  = (\ (a :: *) (x :: a) -> x )
    :: forall (a :: *) . a -> a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *). forall (b :: *) . a -> b -> a;


-- addition of natural numbers
let plus =
  natElim
    ( \ (_ :: Nat) -> Nat -> Nat )           -- motive
    ( \ (n :: Nat) -> n )                    -- case for Zero
    ( \ (p :: Nat) (rec :: Nat -> Nat) (n :: Nat) -> Succ (rec n) );   -- case for Succ

-- predecessor, mapping 0 to 0
let pred =
  natElim
    ( \ (_ :: Nat) -> Nat )
    Zero
    ( \ (n1 :: Nat) (rec :: Nat) -> n1 );

-- a simpler elimination scheme for natural numbers
let natFold =
  ( \ (m :: *) (mz :: m) (ms :: m -> m) ->
            natElim
                   ( \ (_ :: Nat) -> m )
                   mz
                   ( \ (n1 :: Nat) (rec :: m) -> ms rec ) )
  :: forall (m :: *) . m -> (m -> m) -> Nat -> m;
