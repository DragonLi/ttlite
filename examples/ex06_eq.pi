let id  = (\ (a :: *) (x :: a) . x )
    :: forall (a :: *) (x :: a) . a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *) (b :: *) (_ :: a) (_ :: b) . a;

-- Leibniz principle (look at the type signature)
let leibniz =
  ( \ (a :: *) (b :: *) (f :: forall (_ :: a) . b) (x :: a) (y :: a) (eq :: Eq a x y) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq b (f x) (f y))
            (\ (x :: a) -> Refl b (f x))
            x
            y
            eq)
  :: forall (a :: *) (b :: *) (f :: forall (_ :: a) . b) (x :: a) (y :: a) (_ :: Eq a x y) . Eq b (f x) (f y);

-- symmetry of (general) equality
let symm =
  ( \ (a :: *) (x :: a) (y :: a) (eq :: Eq a x y) ->
    eqElim a
        (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq a y x)
        (\ (x :: a) -> Refl a x)
        x
        y
        eq)
  :: forall (a :: *) (x :: a) (y :: a) (_ :: Eq a x y) . Eq a y x;


-- transitivity of (general) equality
let tran =
  ( \ (a :: *) (x :: a) (y :: a) (z :: a) (eq_x_y :: Eq a x y) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> forall (z :: a) (_ :: Eq a y z) . Eq a x z)
            (\ (x :: a) (z :: a) (eq_x_z :: Eq a x z) -> eq_x_z)
             x
             y
             eq_x_y z )
  :: forall (a :: *) (x :: a) (y :: a) (z :: a) (_ :: Eq a x y) (_ :: Eq a y z) . Eq a x z;

-- apply an equality proof on two types
-- input: proof that two types A and P are equal
-- output is a function from A to B (it is constructed in a trivial way (as id))
--let apply =
--  eqElim * (\ (a :: *) (b :: *) (eq_a_b :: Eq * a b) -> a -> b) id
--  :: forall (A :: *) (B :: *) (_ :: Eq * A B) . A -> B;

--assume (X :: *);
--assume (x :: X);
--assume (y :: X);

--assume (eqxy :: Eq X x y);

--eqElim X (\ (x:: X) (y :: X) (eq :: Eq X x y) -> X ) (\(x :: X) -> y) x x (Refl X x);

--let t = eqElim X (\ (x:: X) (y :: X) (eq :: Eq X x y) -> Eq X x y ) (\(x :: X) -> Refl X x) x x (Refl X x);
