let id  = (\ (a :: *) (x :: a) . x )
    :: forall (a :: *) (x :: a) . a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *) (b :: *) (_ :: a) (_ :: b) . a;

let Void = Fin_0;
-- unit type
let Unit = Fin_1;
-- constructor
let U = finElem_1_1;

-- booleans
let Bool = Fin_2;
-- constructors
let False = finElem_1_2;
let True  = finElem_2_2;

let abort = \(m :: *) (v :: Void) -> finElim_0 ( \(_ :: Void) -> m) v;

let boolElim =
    \ (m :: forall (_ :: Fin_2) . *) (c1 :: m False) (c2 :: m True) (b :: Fin_2) .
        finElim_2 m c1 c2 b;

let not = boolElim (\ (_ :: Bool) -> Bool) True False;
let and = boolElim (\ (_ :: Bool) -> forall (_ :: Bool) . Bool) (\ (_ :: Bool) -> False) (id Bool);

let or  = boolElim (\ (_ :: Bool) -> forall (_ :: Bool) . Bool) (id Bool) (\ (_ :: Bool) -> True);
let xor = boolElim (\ (_ :: Bool) -> forall (_ :: Bool) . Bool) (id Bool) not;
let if  = boolElim (\ (_ :: Bool) -> forall (_ :: Bool) . Bool) not (id Bool);

-- a simpler elimination scheme for natural numbers
let natFold =
    ( \ (m :: *) (mz :: m) (ms :: forall (_ :: m) . m) (n :: Nat) ->
        natElim
            (\ (_ :: Nat) -> m )
             mz
             (\ (n1 :: Nat) (rec :: m) -> ms rec )
             n )
  :: forall (m :: *) (_ :: m) (_ :: forall (_ :: m) . m) (_ :: Nat) . m;

let even    = natFold Bool True not;
let odd     = natFold Bool False not;
let isZero  = natFold Bool True (\  (_ :: Bool) -> False);
let isSucc  = natFold Bool False (\ (_ :: Bool) -> True);
