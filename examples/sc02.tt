-- here we have proofs of correctness of transformations!!!

-- :r tt/sc02.pi
let id  = (\ (a :: *) (x :: a) . x )
    :: forall (a :: *) (x :: a) . a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *) (b :: *) (_ :: a) (_ :: b) . a;

-- equality congruence for arguments
-- equality congruence
let cong1 =
  ( \ (a :: *) (b :: *) (f :: forall (_ :: a) . b) (x :: a) (y :: a) (eq :: Eq a x y) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq b (f x) (f y))
            (\ (x :: a) -> Refl b (f x))
            x
            y
            eq)
  :: forall (a :: *) (b :: *) (f :: forall (_ :: a) . b) (x :: a) (y :: a) (_ :: Eq a x y) . Eq b (f x) (f y);

let fcong1 =
  ( \ (a :: *) (b :: *) (x :: a) ->
        eqElim (forall (_ :: a) . b)
            (\ (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq_f_g :: Eq (forall (_ :: a) . b) f g) -> Eq b (f x) (g x))
            (\ (f :: forall (_ :: a) . b) -> Refl b (f x)) )
  :: forall
        (a :: *)
        (b :: *)
        (x :: a)
        (f :: forall (_ :: a) . b)
        (g :: forall (_ :: a) . b)
        (_ :: Eq (forall (_ :: a) . b) f g) .
        Eq b (f x) (g x);

let fargCong =
  ( \ (a :: *) (b :: *) (x :: a) (y :: a) (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq_x_y :: Eq a x y) ->
        eqElim (forall (_ :: a) . b)
            (\ (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq_f_g :: Eq (forall (_ :: a) . b) f g) ->  Eq b (f x) (g y))
            (\ (f :: forall (_ :: a) . b) -> cong1 a b f x y eq_x_y)
            f
            g) ::
  forall (a :: *)
         (b :: *)
         (x :: a)
         (y :: a)
         (f :: forall (_ :: a) . b)
         (g :: forall (_ :: a) . b)
         (_ :: Eq a x y)
         (_ :: Eq (forall (_ :: a) . b) f g) .
         Eq b (f x) (g y);

let cong2 =
     \ (a :: *)
       (b :: *)
       (c :: *)
       (f :: forall (_ :: a) (_ :: b) . c)
       (x1 :: a)
       (x2 :: a)
       (eq_xs :: Eq a x1 x2)
       (y1 :: b)
       (y2 :: b)
       (eq_ys :: Eq b y1 y2) ->
        fargCong b c y1 y2 (f x1) (f x2) eq_ys (cong1 a (forall (_ :: b) . c) f x1 x2 eq_xs);


let plus = \ (n :: Nat) ->
  natElim
    ( \ (_ :: Nat) -> forall (_ :: Nat) . Nat )           -- motive
    ( \ (n :: Nat) -> n )                    -- case for Zero
    ( \ (p :: Nat) (rec :: forall (_ :: Nat) . Nat) (n :: Nat) -> Succ (rec n) ) n;   -- case for Succ

let plusX =
    \ (x :: Nat) (y :: Nat) ->
        natElim
        (\ (_ :: Nat) -> Nat )
        y
        ( \(x1 :: Nat) (rec :: Nat) -> Succ rec ) x;

let plus2 =
    \(x :: Nat) (y :: Nat) (z :: Nat) -> plus (plus x y) z;

let plus0 = \(x :: Nat) -> plus x Zero;

let pred =
  natElim
    ( \ (_ :: Nat) -> Nat )
    Zero
    ( \ (n1 :: Nat) (rec :: Nat) -> n1 );

let pred0 =
  natElim
    ( \ (_ :: Nat) -> Nat )
    Zero
    ( \ (n1 :: Nat) (rec :: Nat) -> rec );

let id1 =
  natElim
    ( \ (_ :: Nat) -> Nat )
    Zero
    ( \ (n1 :: Nat) (rec :: Nat) -> pred0 n1 );


let xxx = \ (x :: Nat) -> pred0 (plus x (Succ Zero));
--sc2 xxx;

let xxx1 = \ (x :: Nat) (y :: Nat) -> pred0 (plus x y);
--sc2 xxx1;


let yyy = \ (x :: Nat) -> pred (plus x Zero);
--sc2 yyy;

let zzz = \ (x :: Nat) -> Succ x;

let yyyNorm =
    (\ (a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) -> b)
            (natElim
                (\ (b :: Nat) -> forall (c :: Nat) . Nat)
                (\ (b :: Nat) -> b)
                (\ (b :: Nat) -> \ (c :: forall (c :: Nat) . Nat) -> \ (d :: Nat) -> Succ (c d))
                a
                Zero)) :: forall (a :: Nat) . Nat;

let yyySc =
    (\ (a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) ->
                natElim
                (\ (d :: Nat) -> Nat)
                Zero
                (\ (d :: Nat) -> \ (e :: Nat) -> Succ e)
                b) a) :: forall (a :: Nat) . Nat;

let proof =
    \(a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Eq Nat (yyyNorm b) (yyySc b))
            (Refl Nat Zero);

let yyy1 = \(x :: Nat) -> yyy (Succ x);

let yyy1Norm = \ (a :: Nat) -> natElim (\ (b :: Nat) -> forall (c :: Nat) . Nat)
    (\ (b :: Nat) -> b)
    (\ (b :: Nat) -> \ (c :: forall (c :: Nat) . Nat) -> \ (d :: Nat) -> Succ
                    (c d))
    a
    Zero;


let yyy1Sc =
\ (a :: Nat) -> natElim (\ (b :: Nat) -> Nat) Zero
    (\ (b :: Nat) -> \ (c :: Nat) -> Succ c)
    a;

let natId =
    \(a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) -> Succ c)
            a;

let natId1 =
    \(a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) -> Succ c)
            a;


let proof =
    (\ (a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Eq Nat (natId b) (natId b))
            (Refl Nat Zero)
            ( \ (b :: Nat) (c :: Eq Nat (natId b) (natId b)) ->
                cong1 Nat Nat Succ (natId b) (natId b) c) a) ::
                forall (b :: Nat) . Eq Nat (natId b) (natId b);

assume (xx :: Nat);
assume (c :: Nat);

--sc2 natId;

let plus3_1 = \ (x :: Nat) (y :: Nat) (z :: Nat) -> plus (plus x y) z;

--sc2 plus3_1;

let plus3_2 = \ (x :: Nat) (y :: Nat) (z :: Nat) -> plus (plus x y) z;

--sc2 plus3_2;

let plus1 = \ (x :: Nat) (y :: Nat) -> (plus x y);

--sc2 plus;

--sc2 (id Nat);

assume (x :: Nat);
assume (y :: Nat);
assume (z :: Nat);


sc plus x y;
--sc2 plus x y;



let list2zero =
    listElim Nat (\ (_ :: List Nat) -> Nat) Zero (\ (h :: Nat) (t :: List Nat) (rec :: Nat) -> Zero);

assume (l :: List Nat);



let i9 = listElim Nat
(\ (a :: List Nat) -> Eq Nat
        (listElim Nat (\ (b :: List Nat) -> Nat) Zero
            (\ (b :: Nat) -> \ (c :: List Nat) -> \ (d :: Nat) -> Zero)
            a)
        (listElim Nat (\ (b :: List Nat) -> Nat) Zero
            (\ (b :: Nat) -> \ (c :: List Nat) -> \ (d :: Nat) -> Zero)
            a))
(Refl Nat Zero)
(\ (a :: Nat) -> \ (b :: List Nat) -> \ (c :: Eq Nat
            (listElim Nat (\ (c :: List Nat) -> Nat) Zero
                (\ (c :: Nat) -> \ (d :: List Nat) -> \ (e :: Nat) -> Zero)
                b)
            (listElim Nat (\ (c :: List Nat) -> Nat) Zero
                (\ (c :: Nat) -> \ (d :: List Nat) -> \ (e :: Nat) -> Zero)
                b)) -> Refl Nat Zero)
l;

sc2 list2zero l;

let list2Nil =
    listElim Nat (\ (_ :: List Nat) -> List Nat) (Nil Nat) (\ (h :: Nat) (t :: List Nat) (rec :: List Nat) -> Nil Nat);

sc2 list2Nil l;


let appendType = forall (a :: *) . forall (_ :: List a) . forall (_ :: List a) . List a;
let append =
  (\(a :: *) (xs :: List a) (ys :: List a) ->
    listElim a (\(_ :: List a) -> List a) ys (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v w) xs) ::
        appendType;


assume (l1 :: List Nat);
assume (l2 :: List Nat);

--let listId = \ (a :: *) -> listElim a (\ (_ :: List a) -> List a ) (Nil a) (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v w);

let listId1 = \ (a :: *) -> listElim a (\ (_ :: List a) -> List a ) (Nil a) (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v vs);
let listId2 = \ (a :: *) -> listElim a (\ (_ :: List a) -> List a ) (Nil a) (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v vs);


sc append Nat l1 l2;
sc listId1 Nat l1;

sc2 append Nat l1 l2;



--sc natId x;

assume (b :: List Nat);
assume (n :: Nat);

let pp =
    fargCong
    (List Nat)
    (List Nat)
    b
    b
    (Cons Nat n)
    (Cons Nat n)
    (Refl (List Nat) b)
    (Refl (forall (_ :: List Nat) . List Nat) (Cons Nat n) );

--Cons Nat n;

listElim Nat
(\ (a :: List Nat) -> Eq (List Nat)
        (listId1 Nat a)
        (listId1 Nat a))
(Refl (List Nat) (Nil Nat))
(\ (a :: Nat) -> \ (b :: List Nat) -> \ (c :: Eq (List Nat) (listId1 Nat b) (listId1 Nat b)) ->
  fargCong
    (List Nat)
    (List Nat)
    b
    b
    (Cons Nat a)
    (Cons Nat a)
    (Refl (List Nat) b)
    (Refl (forall (_ :: List Nat) . List Nat) (Cons Nat a) )
    ) ;


let p2 = (\ (a :: Nat) -> \ (b :: List Nat) -> \ (c :: Eq (List Nat)
            (listElim Nat (\ (c :: List Nat) -> List Nat) (Nil Nat)
                (\ (c :: Nat) -> \ (d :: List Nat) -> \ (e :: List Nat) -> Cons
                                Nat
                                c
                                d)
                b)
            (listElim Nat (\ (c :: List Nat) -> List Nat) (Nil Nat)
                (\ (c :: Nat) -> \ (d :: List Nat) -> \ (e :: List Nat) -> Cons
                                Nat
                                c
                                d)
                b)) -> fargCong (List Nat) (List Nat) b b (Cons Nat a)
                (Cons Nat a)
                (Refl (List Nat) b)
                (cong1 Nat (forall (d :: List Nat) . List Nat) (Cons Nat) a a
                    (Refl Nat a)));

let ee =
listElim Nat
(\ (a :: List Nat) -> Eq (List Nat)
        (listElim Nat (\ (b :: List Nat) -> List Nat) (Nil Nat)
            (\ (b :: Nat) -> \ (c :: List Nat) -> \ (d :: List Nat) -> Cons
                            Nat
                            b
                            c)
            a)
        (listElim Nat (\ (b :: List Nat) -> List Nat) (Nil Nat)
            (\ (b :: Nat) -> \ (c :: List Nat) -> \ (d :: List Nat) -> Cons
                            Nat
                            b
                            c)
            a))
(Refl (List Nat) (Nil Nat))
(\ (a :: Nat) -> \ (b :: List Nat) -> \ (c :: Eq (List Nat)
            (listElim Nat (\ (c :: List Nat) -> List Nat) (Nil Nat)
                (\ (c :: Nat) -> \ (d :: List Nat) -> \ (e :: List Nat) -> Cons
                                Nat
                                c
                                d)
                b)
            (listElim Nat (\ (c :: List Nat) -> List Nat) (Nil Nat)
                (\ (c :: Nat) -> \ (d :: List Nat) -> \ (e :: List Nat) -> Cons
                                Nat
                                c
                                d)
                b)) -> fargCong (List Nat) (List Nat) b b (Cons Nat a)
                (Cons Nat a)
                (Refl (List Nat) b)
                (cong1 Nat (forall (d :: List Nat) . List Nat) (Cons Nat) a a
                    (Refl Nat a)))
b;

assume (b1 :: List Nat);
--sc2 listId1 Nat b;
sc append Nat b b1;





sc append Nat b b1;

let scAppend_b1_1 = listElim
        Nat
        (\ (a :: List Nat) -> List Nat)
        b1
        (\ (a :: Nat) -> \ (bb :: List Nat) -> \ (c :: List Nat) ->
            Cons
            Nat
            a
            (listElim Nat (\ (d :: List Nat) -> List Nat)
                                b1
                                (\ (d :: Nat) -> \ (e :: List Nat) -> \ (f :: List Nat) -> Cons
                                    Nat
                                    d
                                    f)
                    bb));

let scAppend_b1_2 = (\ (bb :: List Nat) -> (listElim Nat (\ (d :: List Nat) -> List Nat)
                                b1
                                (\ (d :: Nat) -> \ (e :: List Nat) -> \ (f :: List Nat) -> Cons
                                    Nat
                                    d
                                    f)
                    bb));

let ee1 =
listElim Nat
    (\ (a :: List Nat) ->
        Eq (List Nat)
        (append Nat a b1)
        (append Nat a b1))
(Refl (List Nat) b1)

(\ (a :: Nat) -> \ (b :: List Nat) -> \ (c :: Eq (List Nat) (append Nat b b1) (append Nat b b1)) ->
  fargCong
    (List Nat)
    (List Nat)
    (append Nat b b1)
    (append Nat b b1)
    (Cons Nat a)
    (Cons Nat a)
    c
    (Refl (forall (_ :: List Nat) . List Nat) (Cons Nat a) )
    );

--let scAppend2  = \ (xs :: List Nat) (ys :: List Nat) -> 1;

--sc append Nat b b1;

let scAppend_b1_3 = listElim
        Nat
        (\ (a :: List Nat) -> List Nat)
        b1
        (\ (a :: Nat) -> \ (bb :: List Nat) -> \ (c :: List Nat) ->
            Cons
            Nat
            a
            (scAppend_b1_2 bb));

assume (ff :: forall (b :: List Nat). Eq (List Nat) (append Nat b b1) (scAppend_b1_2 b));

let ee3 =
listElim Nat
    (\ (a :: List Nat) ->
        Eq (List Nat)
        (append Nat a b1)
        (scAppend_b1_2 a))
(Refl (List Nat) b1)

(\ (a :: Nat) -> \ (b :: List Nat) -> \ (c :: Eq (List Nat) (append Nat b b1) (scAppend_b1_2 b)) ->
  fargCong
    (List Nat)
    (List Nat)
    (append Nat b b1)
    (scAppend_b1_2 b)
    (Cons Nat a)
    (Cons Nat a)
    c
    (Refl (forall (_ :: List Nat) . List Nat) (Cons Nat a) )
    );

let ee2 =
listElim Nat
    (\ (a :: List Nat) ->
        Eq (List Nat)
        (append Nat a b1)
        (scAppend_b1_3 a))
    (Refl (List Nat) b1)
    (\ (a :: Nat) -> \ (b :: List Nat) -> \ (c :: Eq (List Nat) (append Nat b b1) (scAppend_b1_3 b)) ->
      fargCong
          (List Nat)
          (List Nat)
          (append Nat b b1)
          (scAppend_b1_2 b)
          (Cons Nat a)
          (Cons Nat a)
          (ee3 b)
          (Refl (forall (_ :: List Nat) . List Nat) (Cons Nat a) )
          ) b :: Eq (List Nat)
                         (append Nat b b1)
                         (scAppend_b1_3 b);

sc2 listId1 Nat l1;
sc2 append Nat b b1;

sc plus x y;

sc plusX x y;

--sc2 plusX x y;

--sc2 plus (plus x y) z;

--sc plus x y;
sc2 plus x y;

sc2 natId x;

sc append Nat b b1;

-- first element of a dependent pair
let fst1 = \ (a :: *) (b :: forall (_ :: a) . *) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (_ :: exists (x :: a) . b x) -> a)
                (\(x :: a) (y :: b x) -> x)
                p;

assume (A1 :: *);
assume (B1 :: forall (_ :: A1) . *);

assume ($p :: exists (x :: A1) . B1 x);

sc fst1 A1 B1 $p;
sc2 fst1 A1 B1 $p;

let snd1 = \ (a :: *) (b :: forall (_ :: a) . *) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (p :: (exists (x :: a) . b x)) -> b (fst1 a b p))
                (\(x :: a) (y :: b x) -> y)
                p;

sc snd1 A1 B1 $p;
sc2 snd1 A1 B1 $p;

let ee = exists (x :: Nat) . Eq Nat x (Succ Zero);

--let eep = dpair (exists (x :: Nat) . Eq Nat x 1) 1 (Refl Nat 1) :: ee;

--sc eep;
