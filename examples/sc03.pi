------------------
-- LIBRARY FUNCTIONS
------------------

let id  = (\ (a :: *) (x :: a) -> x )
    :: forall (a :: *) . a -> a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *). forall (b :: *) . a -> b -> a;

let cong1 =
  ( \ (a :: *) (b :: *) (f :: a -> b) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq b (f x) (f y))
            (\ (x :: a) -> Refl b (f x)) )
  :: forall (a :: *) (b :: *) (f :: a -> b) (x :: a) (y :: a) . Eq a x y -> Eq b (f x) (f y);

let fargCong =
  ( \ (a :: *) (b :: *) (x :: a) (y :: a) (f :: a -> b) (g :: a -> b) (eq_x_y :: Eq a x y) ->
        eqElim (a -> b)
            (\ (f :: a -> b) (g :: a -> b) (eq_f_g :: Eq (a -> b) f g) ->  Eq b (f x) (g y))
            (\ (f :: a -> b) -> cong1 a b f x y eq_x_y)
            f
            g) ::
  forall (a :: *)
         (b :: *)
         (x :: a)
         (y :: a)
         (f :: a -> b)
         (g :: a -> b) .
         Eq a x y -> Eq (a -> b) f g -> Eq b (f x) (g y);

let cong2 =
     \ (a :: *)
       (b :: *)
       (c :: *)
       (f :: a -> b -> c)
       (x1 :: a)
       (x2 :: a)
       (eq_xs :: Eq a x1 x2)
       (y1 :: b)
       (y2 :: b)
       (eq_ys :: Eq b y1 y2) ->
        fargCong b c y1 y2 (f x1) (f x2) eq_ys (cong1 a (b -> c) f x1 x2 eq_xs);


------------------
-- LISTS
------------------

let appendType = forall (a :: *) . forall (_ :: List a) . forall (_ :: List a) . List a;
let append =
  (\(a :: *) (xs :: List a) (ys :: List a) ->
    listElim a (\(_ :: List a) -> List a) ys (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v w) xs) ::
        appendType;

assume
    ($l1 :: List Nat)
    ($l2 :: List Nat)
    ($l3 :: List Nat);

-- look into results they are equal
sc append Nat (append Nat $l1 $l2) $l3;
sc append Nat $l1 (append Nat $l2 $l3);

sc2 append Nat (append Nat $l1 $l2) $l3;

------------------
-- FINITE TYPES
------------------

let Void = Fin_0;
-- unit type
let Unit = Fin_1;
-- constructor
let U = finElem_1_1;

-- booleans
let Bool = Fin_2;
-- constructors
let False = finElem_1_2;
let True  = finElem_2_2;

let abort = \(m :: *) (v :: Void) -> finElim_0 ( \(_ :: Void) -> m) v;

let not = finElim_2 (\ (_ :: Bool) -> Bool) True False;
let and = finElim_2 (\ (_ :: Bool) -> Bool -> Bool) (\ (_ :: Bool) -> False) (id Bool);
let or  = finElim_2 (\ (_ :: Bool) -> Bool -> Bool) (id Bool) (\ (_ :: Bool) -> True);

assume
    ($b1 :: Bool)
    ($b2 :: Bool);

sc not $b1;
sc2 not $b1;

sc and $b1 $b2;

sc and $b1 $b1;
sc2 and $b1 $b1;

sc or $b1 $b1;
sc2 or $b1 $b1;

---------------
-- PRODUCT
---------------

let fst = (\ (a :: *) (b :: *) (p :: Product a b) ->
                    productElim a b (\ (_ :: Product a b) -> a) (\(x :: a) (y :: b) -> x) p);
let snd = (\ (a :: *) (b :: *) (p :: Product a b) ->
                    productElim a b (\ (_ :: Product a b) -> b) (\(x :: a) (y :: b) -> y) p);

assume ($p :: Product Nat Nat);

sc (fst Nat Nat $p);
sc2 (fst Nat Nat $p);

Pair Nat Nat (fst Nat Nat $p) (snd Nat Nat $p);

sc Pair Nat Nat (fst Nat Nat $p) (snd Nat Nat $p);

let productId =
    productElim Nat Nat (\ (_ :: Product Nat Nat) -> Product Nat Nat) (\(x :: Nat) (y :: Nat) -> Pair Nat Nat x y);

sc productId $p;

let thPId =
    forall (p :: Product Nat Nat) . Eq (Product Nat Nat) p (productId p);

-- TODO: currently such code cannot be produced by a supercompiler
let proofPId =
    (\ (p :: Product Nat Nat) ->
        productElim
            Nat
            Nat
            (\ (p :: Product Nat Nat) -> Eq (Product Nat Nat) p (productId p))
            (\ (x :: Nat) (y :: Nat) -> Refl (Product Nat Nat) (Pair Nat Nat x y))
            p
            ) :: thPId;

------
-- SUM
-----

let thSum01 =
    forall (A :: *) (B :: *). Sum A B -> Sum B A;
let proofSum01 =
    (\ (A :: *) (B :: *) (s :: Sum A B) -> sumElim A B (\ (_ :: Sum A B) -> Sum B A) (InR B A) (InL B A) s)
        :: thSum01;

assume ($n1 :: Nat) ($n2 :: Nat);
assume ($s :: Sum Nat Nat);

sc proofSum01 Nat Nat $s;

sc2 proofSum01 Nat Nat $s;

--------------------------
-- Dependent product
--------------------------

let fst1 = \ (a :: *) (b :: a -> *) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (_ :: exists (x :: a) . b x) -> a)
                (\(x :: a) (y :: b x) -> x)
                p;

assume (A1 :: *);
assume (B1 :: A1 -> *);

assume ($p :: exists (x :: A1) . B1 x);

sc2 fst1 A1 B1 $p;

let snd1 = \ (a :: *) (b :: a -> *) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (p :: (exists (x :: a) . b x)) -> b (fst1 a b p))
                (\(x :: a) (y :: b x) -> y)
                p;

sc2 snd1 A1 B1 $p;

let ee = exists (x :: Nat) . Eq Nat x (Succ Zero);

let eep = dpair (exists (x :: Nat) . Eq Nat x (Succ Zero)) (Succ Zero) (Refl Nat (Succ Zero)) :: ee;

sc2 eep;

sc2 Pair Nat Nat (Succ Zero) (Succ Zero);