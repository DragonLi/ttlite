
let id  = (\ (a :: *) (x :: a) . x )
    :: forall (a :: *) (x :: a) . a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *) (b :: *) (_ :: a) (_ :: b) . a;

let cong1 =
  ( \ (a :: *) (b :: *) (f :: forall (_ :: a) . b) (x :: a) (y :: a) (eq :: Eq a x y) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq b (f x) (f y))
            (\ (x :: a) -> Refl b (f x))
            x
            y
            eq)
  :: forall (a :: *) (b :: *) (f :: forall (_ :: a) . b) (x :: a) (y :: a) (_ :: Eq a x y) . Eq b (f x) (f y);

let fcong1 =
  ( \ (a :: *) (b :: *) (x :: a) (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq :: Eq (forall (_ :: a) . b) f g) ->
        eqElim
            (forall (_ :: a) . b)
            (\ (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq_f_g :: Eq (forall (_ :: a) . b) f g) -> Eq b (f x) (g x))
            (\ (f :: forall (_ :: a) . b) -> Refl b (f x))
            f
            g
            eq)
  :: forall
        (a :: *)
        (b :: *)
        (x :: a)
        (f :: forall (_ :: a) . b)
        (g :: forall (_ :: a) . b)
        (_ :: Eq (forall (_ :: a) . b) f g) .
        Eq b (f x) (g x);

let fargCong =
  ( \ (a :: *) (b :: *) (x :: a) (y :: a) (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq_x_y :: Eq a x y) (eq_f_g :: Eq (forall (_ :: a) . b) f g)  ->
        eqElim (forall (_ :: a) . b)
            (\ (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq_f_g :: Eq (forall (_ :: a) . b) f g) ->  Eq b (f x) (g y))
            (\ (f :: forall (_ :: a) . b) -> cong1 a b f x y eq_x_y)
            f
            g
            eq_f_g) ::
  forall (a :: *)
         (b :: *)
         (x :: a)
         (y :: a)
         (f :: forall (_ :: a) . b)
         (g :: forall (_ :: a) . b)
         (_ :: Eq a x y)
         (_ :: Eq (forall (_ :: a) . b) f g) .
         Eq b (f x) (g y);

let cong2 =
     \ (a :: *)
       (b :: *)
       (c :: *)
       (f :: forall (_ :: a) (_ :: b) . c)
       (x1 :: a)
       (x2 :: a)
       (eq_xs :: Eq a x1 x2)
       (y1 :: b)
       (y2 :: b)
       (eq_ys :: Eq b y1 y2) ->
        fargCong b c y1 y2 (f x1) (f x2) eq_ys (cong1 a (forall (_ :: b) . c) f x1 x2 eq_xs);


------------------
-- LISTS
------------------

let appendType = forall (a :: *) . forall (_ :: List a) . forall (_ :: List a) . List a;
let append =
  (\(a :: *) (xs :: List a) (ys :: List a) ->
    listElim a (\(_ :: List a) -> List a) ys (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v w) xs) ::
        appendType;

assume
    ($l1 :: List Nat)
    ($l2 :: List Nat)
    ($l3 :: List Nat);

-- look into results they are equal
sc append Nat (append Nat $l1 $l2) $l3;
sc append Nat $l1 (append Nat $l2 $l3);

sc2 append Nat (append Nat $l1 $l2) $l3;

------------------
-- FINITE TYPES
------------------

let Void = Fin_0;
-- unit type
let Unit = Fin_1;
-- constructor
let U = finElem_1_1;

-- booleans
let Bool = Fin_2;
-- constructors
let False = finElem_1_2;
let True  = finElem_2_2;

let abort = \(m :: *) (v :: Void) -> finElim_0 ( \(_ :: Void) -> m) v;

let boolElim =
    \ (m :: forall (_ :: Fin_2) . *) (c1 :: m False) (c2 :: m True) (b :: Fin_2) .
        finElim_2 m c1 c2 b;

let not = boolElim (\ (_ :: Bool) -> Bool) True False;
let and = boolElim (\ (_ :: Bool) -> forall (_ :: Bool) . Bool) (\ (_ :: Bool) -> False) (id Bool);

let or  = boolElim (\ (_ :: Bool) -> forall (_ :: Bool) . Bool) (id Bool) (\ (_ :: Bool) -> True);
let xor = boolElim (\ (_ :: Bool) -> forall (_ :: Bool) . Bool) (id Bool) not;
let if  = boolElim (\ (_ :: Bool) -> forall (_ :: Bool) . Bool) not (id Bool);

assume
    ($b1 :: Bool)
    ($b2 :: Bool);

sc not $b1;
sc2 not $b1;

sc and $b1 $b2;

sc and $b1 $b1;
sc2 and $b1 $b1;

sc or $b1 $b1;
sc2 or $b1 $b1;

let fst = (\ (a :: *) (b :: *) (p :: Product a b) ->
                    productElim a b (\ (_ :: Product a b) -> a) (\(x :: a) (y :: b) -> x) p);
let snd = (\ (a :: *) (b :: *) (p :: Product a b) ->
                    productElim a b (\ (_ :: Product a b) -> b) (\(x :: a) (y :: b) -> y) p);

assume ($p :: Product Nat Nat);

sc (fst Nat Nat $p);
sc2 (fst Nat Nat $p);

Pair Nat Nat (fst Nat Nat $p) (snd Nat Nat $p);

sc Pair Nat Nat (fst Nat Nat $p) (snd Nat Nat $p);

let productId = \ (p :: Product Nat Nat) ->
    productElim Nat Nat (\ (_ :: Product Nat Nat) -> Product Nat Nat) (\(x :: Nat) (y :: Nat) -> Pair Nat Nat x y) p;

sc productId $p;

let thPId =
    forall (p :: Product Nat Nat) . Eq (Product Nat Nat) p (productId p);

-- TODO: currently such code cannot be produced by a supercompiler
let proofPId =
    (\ (p :: Product Nat Nat) ->
        productElim
            Nat
            Nat
            (\ (p :: Product Nat Nat) -> Eq (Product Nat Nat) p (productId p))
            (\ (x :: Nat) (y :: Nat) -> Refl (Product Nat Nat) (Pair Nat Nat x y))
            p
            ) :: thPId;

let thSum01 =
    forall (A :: *) (B :: *) (_ :: Sum A B) . Sum B A;
let proofSum01 =
    (\ (A :: *) (B :: *) (s :: Sum A B) ->
        sumElim A B
            (\ (_ :: Sum A B) -> Sum B A)
            (\ (a :: A) . InR B A a)
            (\ (b :: B) . InL B A b)
            s)
        :: thSum01;

assume ($n1 :: Nat) ($n2 :: Nat);
assume ($s :: Sum Nat Nat);

sc proofSum01 Nat Nat $s;

sc2 proofSum01 Nat Nat $s;

--------------------------
-- Dependent product
--------------------------

let fst1 = \ (a :: *) (b :: forall (_ :: a) . *) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (_ :: exists (x :: a) . b x) -> a)
                (\(x :: a) (y :: b x) -> x)
                p;

assume (A1 :: *);
assume (B1 :: forall (_ :: A1) . *);

assume ($p :: exists (x :: A1) . B1 x);

sc2 fst1 A1 B1 $p;

let ee = exists (x :: Nat) . Eq Nat x (Succ Zero);

let eep = dpair (exists (x :: Nat) . Eq Nat x (Succ Zero)) (Succ Zero) (Refl Nat (Succ Zero)) :: ee;

sc2 eep;

sc2 Pair Nat Nat (Succ Zero) (Succ Zero);
