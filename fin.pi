-- Finite types
import "nats.pi";

-- empty type
let Void = Fin Zero;
-- no constructor of empty type

-- unit type
let Unit = Fin 1;
-- constructor
let U = FZero 0;

-- booleans
let Bool = Fin 2;
-- constructors
let False = FZero 1;
let True  = FSucc 1 U;

-- False -> 1 :: Nat, False -> True :: Bool

-- embed Fin into Nat
-- calculate "number" of an element of Fin n
-- explicitly writing types for easier understanding
let finNat = finElim ((\ n finN -> Nat) :: forall (n :: Nat) (x :: Fin n) . *)
                     ((\ n -> Zero) :: forall (n :: Nat) . Nat )-- zero case
                     ((\ n finN rec -> Succ rec) :: forall (n:: Nat) (x:: Fin n) (y :: Nat) . Nat);

-- 0
finNat 2 False;
-- 1
finNat 2 True;

let Fin3 = Fin 3;
let f3_1 = FZero 2 :: Fin3;
let f3_2 = FSucc 2 False :: Fin3;
let f3_3 = FSucc 2 True :: Fin3;

let z1 = (\m -> (natElim (\ n -> Fin n -> *)
                        m
                        (\ _ _ _ -> Unit))) ::
                 forall (m :: Void -> *) . forall (a :: Nat) (b :: Fin a) . *;

-- z2 A 0 = Void -> A;
-- z2 _ n = Fin n -> Unit
let z2 = (\m -> (natElim (\ n -> Fin n -> *)
                        (\ _ -> m)
                        (\ _ _ _ -> Unit))) ::
                 forall (m :: *) . forall (a :: Nat) (b :: Fin a) . *;


-- void eliminator
-- given Void it can produce anything!!

let voidElim =
  ( \ m -> finElim (z1 m)
                   (\ _ -> U)
                   (\ _ _ _ -> U)
                   0 )
  :: forall (m :: Void -> *) (v :: Void) . m v;


-- simplified version of voidEliminator.
-- given void can produce a value of any type;
-- the magic here is that if you some how get x :: Void, you can produce anything!!!
-- here it is hardcoded via finElim
let voidElim1 =
  ( \ m -> finElim (z2 m)
                   (\ n -> U)
                   (\ n _ _ -> U)
                   0 )
  :: forall (m :: *) (v :: Void) . m;
