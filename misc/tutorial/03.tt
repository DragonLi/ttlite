-- curry-howard isomorphism for simplest types

-- PART1 -- AND

-- SIC! - proj1 is a term!
-- A /\ B -> A
let proj1 =
    forall (A :: *) (B :: *) (p :: Product A B) . A;

-- fst :: Product[A, B] -> A
-- fst Pair[A, B](x, y) = x
-- A /\ B => A
let fst =
    (\ (A :: *) (B :: *) (p :: Product A B) ->
        productElim A B (\ (_ :: Product A B) -> A) (\(x :: A) (y :: B) -> x) p)
            :: proj1;

let proj2 =
    forall (A :: *) (B :: *) (p :: Product A B) . B;

-- snd :: Product[A, B] -> B
-- snd Pair[A, B](x, y) = y
-- A /\ B => B
let snd =
    (\ (A :: *) (B :: *) (p :: Product A B) ->
        productElim A B (\ (_ :: Product A B) -> B) (\(x :: A) (y :: B) -> y) p)
            :: proj2;

-- A /\ B => B /\ A
let and_commutativity_theorem =
    forall (A :: *) (B :: *) . Product A B -> Product B A;

let and_commutativity_proof =
    (\ (A :: *) (B :: *) (p :: Product A B) ->
        Pair B A (snd A B p) (fst A B p))
            :: and_commutativity_theorem;

-- A or B => B or A
let or_commutativity_theorem =
    forall (A :: *) (B :: *). Sum A B -> Sum B A;

let or_commutativity_proof =
    (\ (A :: *) (B :: *) (s :: Sum A B) ->
        sumElim A B (\ (_ :: Sum A B) -> Sum B A) (InR B A) (InL B A) s)
            :: or_commutativity_theorem;

-- PART2 -- OR

let or_commutativity_theorem =
    forall (A :: *) (B :: *) (s :: Sum A B) . Sum B A;
let proofSum01 =
    (\ (A :: *) (B :: *) (s :: Sum A B) ->
        sumElim A B (\ (_ :: Sum A B) -> Sum B A) (InR B A) (InL B A) s)
            :: or_commutativity_theorem;




