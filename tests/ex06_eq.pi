-- Leibniz principle (look at the type signature)
let leibniz =
  ( \ (a :: Set) (b :: Set) (f :: forall (_ :: a) . b) (x :: a) (y :: a) (eq :: Eq a x y) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq b (f x) (f y))
            (\ (x :: a) -> Refl b (f x))
            x
            y
            eq)
  :: forall (a :: Set) (b :: Set) (f :: forall (_ :: a) . b) (x :: a) (y :: a) (_ :: Eq a x y) . Eq b (f x) (f y);

-- symmetry of (general) equality
let symm =
  ( \ (a :: Set) (x :: a) (y :: a) (eq :: Eq a x y) ->
    eqElim a
        (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq a y x)
        (\ (x :: a) -> Refl a x)
        x
        y
        eq)
  :: forall (a :: Set) (x :: a) (y :: a) (_ :: Eq a x y) . Eq a y x;


-- transitivity of (general) equality
let tran =
  ( \ (a :: Set) (x :: a) (y :: a) (z :: a) (eq_x_y :: Eq a x y) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> forall (z :: a) (_ :: Eq a y z) . Eq a x z)
            (\ (x :: a) (z :: a) (eq_x_z :: Eq a x z) -> eq_x_z)
             x
             y
             eq_x_y z )
  :: forall (a :: Set) (x :: a) (y :: a) (z :: a) (_ :: Eq a x y) (_ :: Eq a y z) . Eq a x z;

-- apply an equality proof on two types
-- input: proof that two types A and P are equal
-- output is a function from A to B (it is constructed in a trivial way (as id))
--let apply =
--  eqElim Set (\ (a :: Set) (b :: Set) (eq_a_b :: Eq Set a b) -> a -> b) id
--  :: forall (A :: Set) (B :: Set) (_ :: Eq Set A B) . A -> B;

--assume (X :: Set);
--assume (x :: X);
--assume (y :: X);

--assume (eqxy :: Eq X x y);

--eqElim X (\ (x:: X) (y :: X) (eq :: Eq X x y) -> X ) (\(x :: X) -> y) x x (Refl X x);

--let t = eqElim X (\ (x:: X) (y :: X) (eq :: Eq X x y) -> Eq X x y ) (\(x :: X) -> Refl X x) x x (Refl X x);
