-- here we have proofs of correctness of transformations!!!

-- :r tt/sc02.pi
let id  = (\ (a :: Set) (x :: a) . x )
    :: forall (a :: Set) (x :: a) . a;
let const = (\ (a :: Set) (b :: Set) (x :: a) (y :: b) -> x)
    :: forall (a :: Set) (b :: Set) (_ :: a) (_ :: b) . a;

-- equality congruence for arguments
-- equality congruence
let cong1 =
  ( \ (a :: Set) (b :: Set) (f :: forall (_ :: a) . b) (x :: a) (y :: a) (eq :: Eq a x y) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq b (f x) (f y))
            (\ (x :: a) -> Refl b (f x))
            x
            y
            eq)
  :: forall (a :: Set) (b :: Set) (f :: forall (_ :: a) . b) (x :: a) (y :: a) (_ :: Eq a x y) . Eq b (f x) (f y);

let fcong1 =
  ( \ (a :: Set) (b :: Set) (x :: a) (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq :: Eq (forall (_ :: a) . b) f g) ->
        eqElim
            (forall (_ :: a) . b)
            (\ (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq_f_g :: Eq (forall (_ :: a) . b) f g) -> Eq b (f x) (g x))
            (\ (f :: forall (_ :: a) . b) -> Refl b (f x))
            f
            g
            eq)
  :: forall
        (a :: Set)
        (b :: Set)
        (x :: a)
        (f :: forall (_ :: a) . b)
        (g :: forall (_ :: a) . b)
        (_ :: Eq (forall (_ :: a) . b) f g) .
        Eq b (f x) (g x);

let fargCong =
  ( \ (a :: Set) (b :: Set) (x :: a) (y :: a) (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq_x_y :: Eq a x y) (eq_f_g :: Eq (forall (_ :: a) . b) f g)  ->
        eqElim (forall (_ :: a) . b)
            (\ (f :: forall (_ :: a) . b) (g :: forall (_ :: a) . b) (eq_f_g :: Eq (forall (_ :: a) . b) f g) ->  Eq b (f x) (g y))
            (\ (f :: forall (_ :: a) . b) -> cong1 a b f x y eq_x_y)
            f
            g
            eq_f_g) ::
  forall (a :: Set)
         (b :: Set)
         (x :: a)
         (y :: a)
         (f :: forall (_ :: a) . b)
         (g :: forall (_ :: a) . b)
         (_ :: Eq a x y)
         (_ :: Eq (forall (_ :: a) . b) f g) .
         Eq b (f x) (g y);

let cong2 =
     \ (a :: Set)
       (b :: Set)
       (c :: Set)
       (f :: forall (_ :: a) (_ :: b) . c)
       (x1 :: a)
       (x2 :: a)
       (eq_xs :: Eq a x1 x2)
       (y1 :: b)
       (y2 :: b)
       (eq_ys :: Eq b y1 y2) ->
        fargCong b c y1 y2 (f x1) (f x2) eq_ys (cong1 a (forall (_ :: b) . c) f x1 x2 eq_xs);

let plus = \ (n :: Nat) ->
  natElim
    ( \ (_ :: Nat) -> forall (_ :: Nat) . Nat )           -- motive
    ( \ (n :: Nat) -> n )                    -- case for Zero
    ( \ (p :: Nat) (rec :: forall (_ :: Nat) . Nat) (n :: Nat) -> Succ (rec n) ) n;   -- case for Succ

let plusX =
    \ (x :: Nat) (y :: Nat) ->
        natElim
        (\ (_ :: Nat) -> Nat )
        y
        ( \(x1 :: Nat) (rec :: Nat) -> Succ rec ) x;

let plus2 =
    \(x :: Nat) (y :: Nat) (z :: Nat) -> plus (plus x y) z;

let plus0 = \(x :: Nat) -> plus x Zero;

let pred = \ (n :: Nat) ->
  natElim
    ( \ (_ :: Nat) -> Nat )
    Zero
    ( \ (n1 :: Nat) (rec :: Nat) -> n1 )
    n;

let pred0 = \ (n :: Nat) ->
  natElim
    ( \ (_ :: Nat) -> Nat )
    Zero
    ( \ (n1 :: Nat) (rec :: Nat) -> rec )
    n;

let id1 = \ (n :: Nat) ->
  natElim
    ( \ (_ :: Nat) -> Nat )
    Zero
    ( \ (n1 :: Nat) (rec :: Nat) -> pred0 n1 )
    n;

let xxx = \ (x :: Nat) -> pred0 (plus x (Succ Zero));
--sc2 xxx;

let xxx1 = \ (x :: Nat) (y :: Nat) -> pred0 (plus x y);
--sc2 xxx1;

let yyy = \ (x :: Nat) -> pred (plus x Zero);
--sc2 yyy;

let zzz = \ (x :: Nat) -> Succ x;

let yyyNorm =
    (\ (a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) -> b)
            (natElim
                (\ (b :: Nat) -> forall (c :: Nat) . Nat)
                (\ (b :: Nat) -> b)
                (\ (b :: Nat) -> \ (c :: forall (c :: Nat) . Nat) -> \ (d :: Nat) -> Succ (c d))
                a
                Zero)) :: forall (a :: Nat) . Nat;
let yyySc =
    (\ (a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) ->
                natElim
                (\ (d :: Nat) -> Nat)
                Zero
                (\ (d :: Nat) -> \ (e :: Nat) -> Succ e)
                b) a) :: forall (a :: Nat) . Nat;

let yyy1 = \(x :: Nat) -> yyy (Succ x);

let yyy1Norm = \ (a :: Nat) -> natElim (\ (b :: Nat) -> forall (c :: Nat) . Nat)
    (\ (b :: Nat) -> b)
    (\ (b :: Nat) -> \ (c :: forall (c :: Nat) . Nat) -> \ (d :: Nat) -> Succ
                    (c d))
    a
    Zero;

let yyy1Sc =
\ (a :: Nat) -> natElim (\ (b :: Nat) -> Nat) Zero
    (\ (b :: Nat) -> \ (c :: Nat) -> Succ c)
    a;

let natId =
    \(a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) -> Succ c)
            a;

let natId1 =
    \(a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) -> Succ c)
            a;

let proof =
    (\ (a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Eq Nat (natId b) (natId b))
            (Refl Nat Zero)
            ( \ (b :: Nat) (c :: Eq Nat (natId b) (natId b)) ->
                cong1 Nat Nat (\ (n :: Nat) -> Succ n) (natId b) (natId b) c) a) ::
                forall (b :: Nat) . Eq Nat (natId b) (natId b);

assume (xx :: Nat);
assume (c :: Nat);

--sc2 natId;

let plus3_1 = \ (x :: Nat) (y :: Nat) (z :: Nat) -> plus (plus x y) z;

--sc2 plus3_1;

let plus3_2 = \ (x :: Nat) (y :: Nat) (z :: Nat) -> plus (plus x y) z;

--sc2 plus3_2;

let plus1 = \ (x :: Nat) (y :: Nat) -> (plus x y);

assume (x :: Nat);
assume (y :: Nat);
assume (z :: Nat);


sc plus x y;

let list2zero = \ (n :: List Nat) ->
    listElim Nat (\ (_ :: List Nat) -> Nat) Zero (\ (h :: Nat) (t :: List Nat) (rec :: Nat) -> Zero) n;

assume (l :: List Nat);

let i9 = listElim Nat
(\ (a :: List Nat) -> Eq Nat
        (listElim Nat (\ (b :: List Nat) -> Nat) Zero
            (\ (b :: Nat) -> \ (c :: List Nat) -> \ (d :: Nat) -> Zero)
            a)
        (listElim Nat (\ (b :: List Nat) -> Nat) Zero
            (\ (b :: Nat) -> \ (c :: List Nat) -> \ (d :: Nat) -> Zero)
            a))
(Refl Nat Zero)
(\ (a :: Nat) -> \ (b :: List Nat) -> \ (c :: Eq Nat
            (listElim Nat (\ (c :: List Nat) -> Nat) Zero
                (\ (c :: Nat) -> \ (d :: List Nat) -> \ (e :: Nat) -> Zero)
                b)
            (listElim Nat (\ (c :: List Nat) -> Nat) Zero
                (\ (c :: Nat) -> \ (d :: List Nat) -> \ (e :: Nat) -> Zero)
                b)) -> Refl Nat Zero)
l;

sc2 list2zero l;

let list2Nil = \ (n :: List Nat) ->
    listElim Nat (\ (_ :: List Nat) -> List Nat) (Nil Nat) (\ (h :: Nat) (t :: List Nat) (rec :: List Nat) -> Nil Nat) n;

sc2 list2Nil l;

let appendType = forall (a :: Set) . forall (_ :: List a) . forall (_ :: List a) . List a;
let append =
  (\(a :: Set) (xs :: List a) (ys :: List a) ->
    listElim a (\(_ :: List a) -> List a) ys (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v w) xs) ::
        appendType;

assume (l1 :: List Nat);
assume (l2 :: List Nat);

--let listId = \ (a :: Set) -> listElim a (\ (_ :: List a) -> List a ) (Nil a) (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v w);

let listId1 = \ (a :: Set) (xs :: List a) ->
    listElim a (\ (_ :: List a) -> List a ) (Nil a) (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v vs) xs;

let listId2 = \ (a :: Set) (xs :: List a) ->
    listElim a (\ (_ :: List a) -> List a ) (Nil a) (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v vs) xs;

sc append Nat l1 l2;
sc listId1 Nat l1;

sc2 append Nat l1 l2;

assume (b :: List Nat);
assume (n :: Nat);

assume (b1 :: List Nat);
--sc2 listId1 Nat b;
sc append Nat b b1;





sc append Nat b b1;

sc2 listId1 Nat l1;
sc2 append Nat b b1;

sc plus x y;

sc plusX x y;

sc2 plus x y;

sc2 natId x;

sc append Nat b b1;

let fst1 = \ (a :: Set) (b :: forall (_ :: a) . Set) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (_ :: exists (x :: a) . b x) -> a)
                (\(x :: a) (y :: b x) -> x)
                p;

assume (A1 :: Set);
assume (B1 :: forall (_ :: A1) . Set);

assume ($p :: exists (x :: A1) . B1 x);

sc fst1 A1 B1 $p;
sc2 fst1 A1 B1 $p;

let snd1 = \ (a :: Set) (b :: forall (_ :: a) . Set) (p :: (exists (x :: a) . b x)) ->
            sigmaElim
                (exists (x :: a) . b x)
                (\ (p :: (exists (x :: a) . b x)) -> b (fst1 a b p))
                (\(x :: a) (y :: b x) -> y)
                p;

sc snd1 A1 B1 $p;
sc2 snd1 A1 B1 $p;

let ee = exists (x :: Nat) . Eq Nat x (Succ Zero);

