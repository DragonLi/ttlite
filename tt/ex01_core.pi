assume (Bool :: *);
assume (False :: Bool);

let t = \ (x :: *) -> x;

let id  = (\ (a :: *) (x :: a) -> x )
    :: forall (a :: *) . a -> a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *). forall (b :: *) . a -> b -> a;

let const1 = (\ (a :: *) (x :: a) (b :: *) (y :: b) -> x)
    :: forall (a :: *). a -> forall (b :: *) . b -> a;

let const2 = (\ (a :: *) -> a) :: forall (a :: *) . *;
let const3 = (\ (a :: *) ( x :: *) -> a) :: forall (a :: *) . forall (b :: *) . *;

let boolId = id Bool;
let False1 = boolId False;

assume (n :: *);
-- zero element
assume (z :: n);
-- successor element
assume (s :: n -> n);
let numeral = forall (A :: *) . (A -> A) -> (A -> A);
let zero = (\ (f :: n -> n) (x :: n) -> x) :: (n -> n) -> (n -> n);
let zero1 = (\ (A :: *) (f :: A -> A) (x :: A) -> x) :: forall (A :: *). (A -> A) -> A -> A;
let zero2 = (\ (A :: *) (f :: A -> A) (x :: A) -> x) :: numeral;
zero1 Bool;

let plus =
    (\ (m :: numeral) (n :: numeral) (A :: *) (f :: A -> A) (x :: A) -> m A f (n A f x))
        :: numeral -> numeral -> numeral;
