let id  = (\ (a :: *) (x :: a) -> x )
    :: forall (a :: *) . a -> a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *). forall (b :: *) . a -> b -> a;

-- Leibniz principle (look at the type signature)
let leibniz =
  ( \ (a :: *) (b :: *) (f :: a -> b) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq b (f x) (f y)) -- prop = x y eq_x_y, when substituting, we have Eq b (f x) (f x)
            (\ (x :: a) -> Refl b (f x)) )
  :: forall (a :: *) (b :: *) (f :: a -> b) (x :: a) (y :: a) . Eq a x y -> Eq b (f x) (f y);

-- symmetry of (general) equality
let symm =
  ( \ (a :: *) -> eqElim a
             (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq a y x)
             (\ (x :: a) -> Refl a x) )
  :: forall (a :: *) (x :: a) (y :: a) .
     Eq a x y -> Eq a y x;

-- transitivity of (general) equality
let tran =
  ( \ (a :: *) (x :: a) (y :: a) (z :: a) (eq_x_y :: Eq a x y) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> forall (z :: a) . Eq a y z -> Eq a x z)
            (\ (x :: a) (z :: a) (eq_x_z :: Eq a x z) -> eq_x_z)
             x
             y
             eq_x_y z )
  :: forall (a :: *) (x :: a) (y :: a) (z :: a) .
     Eq a x y -> Eq a y z -> Eq a x z;

-- apply an equality proof on two types
-- input: proof that two types A and P are equal
-- output is a function from A to B (it is constructed in a trivial way (as id))
let apply =
  eqElim * (\ (a :: *) (b :: *) (eq_a_b :: Eq * a b) -> a -> b) id
  :: forall (A :: *) (B :: *) (_ :: Eq * A B) . A -> B;
