let id  = (\ (a :: *) (x :: a) -> x )
    :: forall (a :: *) . a -> a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *). forall (b :: *) . a -> b -> a;


-- addition of natural numbers
let plus =
  natElim
    ( \ (_ :: Nat) -> Nat -> Nat )           -- motive
    ( \ (n :: Nat) -> n )                    -- case for Zero
    ( \ (p :: Nat) (rec :: Nat -> Nat) (n :: Nat) -> Succ (rec n) );   -- case for Succ

-- alternative (more readable??) variation of plus
let plus1 =
  (\(x :: Nat) (y :: Nat) ->
    natElim
    ( \ (_ :: Nat) -> Nat )                -- motive
    y                             -- case for Zero
    (\ (n :: Nat) (rec :: Nat) -> Succ rec) x) ::   -- case for Succ
    forall (a :: Nat) (b :: Nat) . Nat;

-- predecessor, mapping 0 to 0
let pred =
  natElim
    ( \ (_ :: Nat) -> Nat )
    Zero
    ( \ (n1 :: Nat) (_ :: Nat) -> n1 );

-- fZSucc0 Z        = a1 :: A
-- fZSucc0 (Succ _) = a2 :: A
-- this function allows to eliminate nats
-- in simple (homo) way
let fZSucc0 =
    (\(A :: *) (a1 :: A) (a2 :: A) -> natElim (\(_ :: Nat) -> A) a1 (\(_ :: Nat) (pred :: A) -> a2))
    :: forall (A :: *) (a1 :: A) (a2 :: A) . Nat -> A;

-- a simpler elimination scheme for natural numbers
-- type of result doesn't depend on n
-- a simpler elimination scheme for natural numbers
let natFold =
  ( \ (m :: *) (mz :: m) (ms :: m -> m) ->
            natElim
                   ( \ (_ :: Nat) -> m )
                   mz
                   ( \ (n1 :: Nat) (rec :: m) -> ms rec ) )
  :: forall (m :: *) . m -> (m -> m) -> Nat -> m;

-- special case for 1
let nat1Elim =
  ( \ (m :: Nat -> *)
      (m0 :: m 0)
      (m1 :: m 1)
      (ms :: forall (a :: Nat) . (m (Succ a)) -> m (Succ (Succ a))) ->
        natElim
            m
            m0
            (\ (p :: Nat) (rec :: m p) -> natElim (\ (n :: Nat) -> m (Succ n)) m1 ms p) )
  :: forall (m :: Nat -> *) . m 0 -> m 1 ->
     (forall n :: Nat . m (Succ n) -> m (Succ (Succ n))) ->
     forall (n :: Nat) . m n;

-- increment by one
let inc = natFold Nat (Succ Zero) Succ;

let appendType = forall (a :: *) . forall (_ :: List a) . forall (_ :: List a) . List a;
let append =
  (\(a :: *) (xs :: List a) (ys :: List a) ->
    listElim a (\(_ :: List a) -> List a) ys (\ (v :: a) (vs :: List a) (w :: List a) -> Cons a v w) xs) ::
        appendType;

let len =
  (\ (a :: *) -> listElim a (\ (_ :: List a) -> Nat) 0 (\ (v :: a) (vs :: List a) (w :: Nat) -> Succ w)) ::
    forall (a :: *) . forall (v :: List a) . Nat;

-- supercompiling everything
sc id;
sc const;
sc plus;
sc plus1;
sc pred;
sc fZSucc0;
sc natFold;
sc nat1Elim;
sc inc;
sc append;
sc len;

assume (A :: *);
let LA = List A;

sc (\(a :: *) (x :: List a) (y :: List a) (z :: List a) -> append a x (append a y z));