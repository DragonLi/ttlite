-- :r tt/sc02.pi
let id  = (\ (a :: *) (x :: a) -> x )
    :: forall (a :: *) . a -> a;
let const = (\ (a :: *) (b :: *) (x :: a) (y :: b) -> x)
    :: forall (a :: *). forall (b :: *) . a -> b -> a;

-- equality congruence
let cong1 =
  ( \ (a :: *) (b :: *) (f :: a -> b) ->
        eqElim a
            (\ (x :: a) (y :: a) (eq_x_y :: Eq a x y) -> Eq b (f x) (f y))
            (\ (x :: a) -> Refl b (f x)) )
  :: forall (a :: *) (b :: *) (f :: a -> b) (x :: a) (y :: a) . Eq a x y -> Eq b (f x) (f y);

let plus =
  natElim
    ( \ (_ :: Nat) -> Nat -> Nat )           -- motive
    ( \ (n :: Nat) -> n )                    -- case for Zero
    ( \ (p :: Nat) (rec :: Nat -> Nat) (n :: Nat) -> Succ (rec n) );   -- case for Succ

let plus2 =
    \(x :: Nat) (y :: Nat) (z :: Nat) -> plus (plus x y) z;

let plus0 = \(x :: Nat) -> plus x 0;

let pred =
  natElim
    ( \ (_ :: Nat) -> Nat )
    Zero
    ( \ (n1 :: Nat) (rec :: Nat) -> n1 );

let pred0 =
  natElim
    ( \ (_ :: Nat) -> Nat )
    0
    ( \ (n1 :: Nat) (rec :: Nat) -> rec );

let id1 =
  natElim
    ( \ (_ :: Nat) -> Nat )
    0
    ( \ (n1 :: Nat) (rec :: Nat) -> pred0 n1 );


let xxx = \ (x :: Nat) -> pred0 (plus x 1);
sc2 xxx;

let xxx1 = \ (x :: Nat) (y :: Nat) -> pred0 (plus x y);
sc2 xxx1;


let yyy = \ (x :: Nat) -> pred (plus x 0);
sc2 yyy;

let zzz = \ (x :: Nat) -> Succ x;

let yyyNorm =
    (\ (a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) -> b)
            (natElim
                (\ (b :: Nat) -> forall c :: Nat . Nat)
                (\ (b :: Nat) -> b)
                (\ (b :: Nat) -> \ (c :: forall c :: Nat . Nat) -> \ (d :: Nat) -> Succ (c d))
                a
                Zero)) :: forall a :: Nat . Nat;

let yyySc =
    (\ (a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) ->
                natElim
                (\ (d :: Nat) -> Nat)
                Zero
                (\ (d :: Nat) -> \ (e :: Nat) -> Succ e)
                b) a) :: forall a :: Nat . Nat;

let proof =
    \(a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Eq Nat (yyyNorm b) (yyySc b))
            (Refl Nat Zero);

let yyy1 = \(x :: Nat) -> yyy (Succ x);

let yyy1Norm = \ (a :: Nat) -> natElim (\ (b :: Nat) -> forall c :: Nat . Nat)
    (\ (b :: Nat) -> b)
    (\ (b :: Nat) -> \ (c :: forall c :: Nat . Nat) -> \ (d :: Nat) -> Succ
                    (c d))
    a
    Zero;


let yyy1Sc =
\ (a :: Nat) -> natElim (\ (b :: Nat) -> Nat) Zero
    (\ (b :: Nat) -> \ (c :: Nat) -> Succ c)
    a;

let natId =
    \(a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) -> Succ c)
            a;

let natId1 =
    \(a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Nat)
            Zero
            (\ (b :: Nat) -> \ (c :: Nat) -> Succ c)
            a;


let proof =
    (\ (a :: Nat) ->
        natElim
            (\ (b :: Nat) -> Eq Nat (natId b) (natId b))
            (Refl Nat 0)
            ( \ (b :: Nat) (c :: Eq Nat (natId b) (natId b)) ->
                cong1 Nat Nat Succ (natId b) (natId b) c) a) ::
                forall b :: Nat . Eq Nat (natId b) (natId b);

assume (xx :: Nat);
assume (c :: Nat);

sc2 natId;

let plus3_1 = \ (x :: Nat) (y :: Nat) (z :: Nat) -> plus (plus x y) z;

sc2 plus3_1;

let plus3_2 = \ (x :: Nat) (y :: Nat) (z :: Nat) -> plus (plus x y) z;

sc2 plus3_2;
